<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>clj</string>
		<string>clojure</string>
	</array>
	<key>foldingStartMarker</key>
	<string>\(\s*$</string>
	<key>foldingStopMarker</key>
	<string>^\s*\)</string>
	<key>keyEquivalent</key>
	<string>^~C</string>
	<key>name</key>
	<string>Clojure</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>match</key>
			<string>;.*$</string>
			<key>name</key>
			<string>comment.line.semi.clojure</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#sexpr</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>expr</key>
		<dict>
			<key>name</key>
			<string>meta.expr.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#keyword</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#vector</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#string</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#number</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#operator</string>
				</dict>
			</array>
		</dict>
		<key>keyword</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>\b(if|cond|do|let|loop|recur|throw|try|catch|finally)\b</string>
					<key>name</key>
					<string>keyword.control.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(monitor-enter|monitor-exit|assoc|touch|drop|take|concat|prn|into|cons|first|rest|frest|rrest|second|lazy-cat|lazy-cons|conj|await|range|iterate)\b</string>
					<key>name</key>
					<string>keyword.other.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(str|print(ln)?|eval|def|defmacro|defn|quote|var|fn|defmulti|defmethod|map|list|hash-map|vector|agent)\b</string>
					<key>name</key>
					<string>storage.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(-&gt;|\.\.|amap|and|areduce|assert|binding|comment|cond|definline|defmatch|defmethod|defmulti|defn|defn-|defonce|defstruct|delay|doc|doseq|dosync|dotimes|doto|fn|for|if-let|lazy-cons|let|locking|loop|memfn|ns|or|prefer-method|proxy-super|proxy|refer-clojure|remove-method|sync|time|when-first|when-let|when-not|when|with-in-str|with-local-vars|with-open|with-out-str|with-precision)\b</string>
					<key>name</key>
					<string>support.function.match.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(associative|branch|class|coll|contains|decimal|delay|distinct|empty|end|even|every|false|float|fn|identical|instance|integer|isa|keyword|list|map|neg|nil|not-any|not-every|number|odd|pos|ratio|reversible|seq|sequential|set|sorted|special-symbol|string|symbol|true|var|zero|vector)\?\b</string>
					<key>name</key>
					<string>support.function.tester.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(zipper|zipmap|xml-zip|xml-seq|with-meta|vector-zip|vector|vec|var-set|var-get|vals|val|use|update-proxy|update-in|up|union|underive|unchecked-subtract|unchecked-negate|unchecked-multiply|unchecked-inc|unchecked-divide|unchecked-dec|unchecked-add|tree-seq|to-array-2d|to-array|test|take-while|take-nth|symbol|supers|subvec|subseq|subs|struct-map|struct|str|split-with|split-at|sorted-set|sorted-map-by|sorted-map|sort-by|sort|some|slurp|shutdown-agents|short|set-validator|set|seque|seq-zip|seq|send-off|send|select-keys|select|rsubseq|rseq|root|rights|right|rfirst|reverse|resultset-seq|resolve|require|replicate|replace|repeatedly|repeat|rename-keys|rename|remove-ns|remove|rem|refer|ref-set|ref|reduce|read-line|read|re-seq|re-pattern|re-matches|re-matcher|re-groups|re-find|rationalize|rand-int|rand|quot|pvec|psummary|psort|proxy-mappings|project|prn-str|println-str|println|printf|print-str|print|preduce|pr-str|pr|pop|pmin|pmax|pmap|pfilter-nils|pfilter-dupes|peek|pdistinct|path|partition|partial|parse|parents|par|pany|num|nthrest|nth|ns-unmap|ns-unalias|ns-resolve|ns-refers|ns-publics|ns-name|ns-map|ns-interns|ns-imports|ns-aliases|not=|not-empty|not|node|next|newline|namespace|name|min-key|min|meta|merge-with|merge|max-key|max|matchexpand-1|matchexpand|mapcat|map-invert|map|make-node|make-hierarchy|make-array|long-array|long|loaded-libs|load-string|load-reader|load-file|load|list*|list|line-seq|lefts|left|last|keyword|keys|key|join|iterator-seq|into-array|intersection|interpose|interleave|int-array|int|inspect-tree|inspect-table|insert-right|insert-left|insert-child|index|inc|in-ns|import|identity|hash-set|hash-map|hash|get-validator|get-proxy-class|get-in|get|gensym|gen-class|gen-and-save-class|gen-and-load-class|format|force|fnseq|flush|float-array|float|find-var|find-ns|find-doc|find|filter|file-seq|ffirst|eval|enumeration-seq|ensure|empty|edit|drop-while|drop-last|down|double-array|double|dorun|doall|distinct|dissoc|disj|difference|descendants|derive|deref|dec|cycle|create-struct|create-ns|count|construct-proxy|constantly|conj|complement|compare|comparator|comp|commute|clojure.set|clojure.parallel|clojure.inspector|clear-agent-errors|class|children|char|cast|cache-seq|byte|butlast|boolean|bit-xor|bit-test|bit-shift-right|bit-shift-left|bit-set|bit-or|bit-not|bit-flip|bit-clear|bit-and-not|bit-and|bigint|bigdec|bean|bases|await-for|assoc-in|aset-short|aset-long|aset-int|aset-float|aset-double|aset-char|aset-byte|aset-boolean|aset|array-map|apply|append-child|ancestors|alter-var-root|alter|all-ns|alias|alength|aget|agent-errors|agent|add-classpath|aclone|accessor)\b</string>
					<key>name</key>
					<string>support.function.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(true|\(\)|false|nil)\b</string>
					<key>name</key>
					<string>constant.language.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b:(private|doc|test|tag)\b</string>
					<key>name</key>
					<string>storage.modifier.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b:(file|line|name|ns|match|argslist)\b</string>
					<key>name</key>
					<string>support.variable.clojure</string>
				</dict>
			</array>
		</dict>
		<key>number</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>\b[0-9]+/[0-9]+\b</string>
					<key>name</key>
					<string>constant.numeric.rat.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b[0-9]+\.[0-9]+\b</string>
					<key>name</key>
					<string>constant.numeric.float.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b[0-9]+\b</string>
					<key>name</key>
					<string>constant.numeric.int.clojure</string>
				</dict>
			</array>
		</dict>
		<key>operator</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(\*|\+|-|/|\&lt;|\&lt;=|=|==|\&gt;|\&gt;=)</string>
					<key>name</key>
					<string>keyword.operator.clojure</string>
				</dict>
			</array>
		</dict>
		<key>sexpr</key>
		<dict>
			<key>begin</key>
			<string>\(</string>
			<key>end</key>
			<string>\)</string>
			<key>name</key>
			<string>meta.sexpr.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=\()(def(?:n|macro))\s+([\-\w\d\*\+\&lt;\&gt;\=\./\\,\~\!\@\#\$\%\^\&amp;]+)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.defn.clojure</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.function.clojure</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?=\))</string>
					<key>name</key>
					<string>meta.defn.clojure</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>\(?\s*\[</string>
							<key>end</key>
							<string>\]\s*\)?</string>
							<key>name</key>
							<string>meta.defn.parameters.clojure</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>match</key>
									<string>\b[\-\w\d\*\+\&lt;\&gt;\=\./\\,\~\!\@\#\$\%\^\&amp;]+\b</string>
									<key>name</key>
									<string>variable.parameter.clojure</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#sexpr</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#expr</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>include</key>
					<string>#keyword</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#expr</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#sexpr</string>
				</dict>
			</array>
		</dict>
		<key>string</key>
		<dict>
			<key>begin</key>
			<string>"</string>
			<key>end</key>
			<string>"</string>
			<key>name</key>
			<string>string.quoted.double.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>\\.</string>
					<key>name</key>
					<string>constant.character.escape.untitled</string>
				</dict>
			</array>
		</dict>
		<key>vector</key>
		<dict>
			<key>begin</key>
			<string>\[</string>
			<key>end</key>
			<string>\]</string>
			<key>name</key>
			<string>meta.vector.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#sexpr</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#keyword</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.clojure</string>
	<key>uuid</key>
	<string>6A87759F-F746-4E84-B788-965B46363202</string>
</dict>
</plist>
